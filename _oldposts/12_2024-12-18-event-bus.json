{
  "body": "EventBus allows publish-subscribe-style communication between components without requiring the components to explicitly register with one another (and thus be aware of each other). It is designed exclusively to replace traditional Java in-process event distribution using explicit registration. It is not a general-purpose publish-subscribe system, nor is it intended for interprocess communication.\nAvoid EventBus\n\nWe recommend against using EventBus. It was designed many years ago, and newer libraries offer better ways to decouple components and react to events.\n\nTo decouple components, we recommend a dependency-injection framework. For Android code, most apps use Dagger. For server code, common options include Guice and Spring. Frameworks typically offer a way to register multiple listeners independently and then request them together as a set (Dagger, Guice, Spring).\n\nTo react to events, we recommend a reactive-streams framework like RxJava (supplemented with its RxAndroid extension if you are building for Android) or Project Reactor. (For the basics of translating code from using an event bus to using a reactive-streams framework, see these two guides: 1, 2.) Some usages of EventBus may be better written using Kotlin coroutines, including Flow and Channels. Yet other usages are better served by individual libraries that provide specialized support for particular use cases.\n\nDisadvantages of EventBus include:\n\n    It makes the cross-references between producer and subscriber harder to find. This can complicate debugging, lead to unintentional reentrant calls, and force apps to eagerly initialize all possible subscribers at startup time.\n    It uses reflection in ways that break when code is processed by optimizers/minimizers like R8 and Proguard.\n    It doesn't offer a way to wait for multiple events before taking action. For example, it doesn't offer a way to wait for multiple producers to all report that they're \"ready,\" nor does it offer a way to batch multiple events from a single producer together.\n    It doesn't support backpressure and other features needed for resilience.\n    It doesn't provide much control of threading.\n    It doesn't offer much monitoring.\n    It doesn't propagate exceptions, so apps don't have a way to react to them.\n    It doesn't interoperate well with RxJava, coroutines, and other more commonly used alternatives.\n    It imposes requirements on the lifecycle of its subscribers. For example, if an event occurs between when one subscriber is removed and the next subscriber is added, the event is dropped.\n    Its performance is suboptimal, especially under Android.\n    It doesn't support parameterized types.\n    With the introduction of lambdas in Java 8, EventBus went from less verbose than listeners to more verbose.\n\n",
  "title": "event bus",
  "date": "2024-12-18"
}